<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dec (carton.Carton__.Dec)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">carton</a> &#x00BB; <a href="../index.html">Carton__</a> &#x00BB; Dec</nav><h1>Module <code>Carton__.Dec</code></h1><nav class="toc"><ul><li><a href="#weight-of-object.">Weight of object.</a></li><li><a href="#value-of-object.">Value of object.</a></li><li><a href="#path-of-object.">Path of object.</a></li><li><a href="#uid-of-object.">Uid of object.</a></li><li><a href="#verify.">Verify.</a></li></ul></nav></header><aside><p>Decoder of a PACK file.</p><p>Along this module, the type <code>('a, 's) io</code> with a <code>'s scheduler</code> is needed for some operations (which use a <i>syscall</i>). To be able to use them, the use must create a new type <code>'s</code> which represents the scheduler. To do that with LWT for example:</p><pre><code class="ml">module Lwt_scheduler = Make (Lwt)

let scheduler =
  let open Lwt.Infix in
  let open Lwt_scheduler in
  {
    bind = (fun x f -&gt; inj (x &gt;&gt;= fun x -&gt; prj (f x)));
    return = (fun x -&gt; inj x);
  }</code></pre><p>The produced module has 2 functions <code>inj</code> and <code>prj</code> to pass from or to an LWT value. The user can use these functions like:</p><pre><code class="ml">let fiber =
  let ( &gt;&gt;= ) = scheduler.bind in
  let return = scheduler.return in

  weight_of_offset scheduler ~map t ~weight:null 0L &gt;&gt;= fun weight -&gt;
  let raw = make_raw ~weight in
  of_offset scheduler ~map t raw ~cursor:0L in
prj fiber ;;
- : (Carton.v, [&gt; error ]) Lwt.t = &lt;abstr&gt;</code></pre></aside><dl><dt class="spec module" id="module-W"><a href="#module-W" class="anchor"></a><code><span class="keyword">module</span> <a href="W/index.html">W</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec type" id="type-weight"><a href="#type-weight" class="anchor"></a><code><span class="keyword">type</span> weight</code><code> = <span class="keyword">private</span> int</code></dt><dd><p>Type of <code>weight</code>. <code>weight</code> is <b>not</b> <i>length</i> of object but bytes needed to extract it.</p></dd></dl><dl><dt class="spec value" id="val-null"><a href="#val-null" class="anchor"></a><code><span class="keyword">val</span> null : <a href="index.html#type-weight">weight</a></code></dt><dd><p><i>zero</i> weight.</p></dd></dl><dl><dt class="spec value" id="val-weight_of_int_exn"><a href="#val-weight_of_int_exn" class="anchor"></a><code><span class="keyword">val</span> weight_of_int_exn : int <span>&#45;&gt;</span> <a href="index.html#type-weight">weight</a></code></dt><dd><p><code>weight_of_int_exn n</code> is the weight of <code>n</code>.</p></dd></dl><dl><dt class="spec type" id="type-read"><a href="#type-read" class="anchor"></a><code><span class="keyword">type</span> <span>('fd, 's) read</span></code><code> = <span class="type-var">'fd</span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> <span>off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> <span><span>(int, <span class="type-var">'s</span>)</span> <a href="../Sigs/index.html#type-io">Carton__.Sigs.io</a></span></code></dt><dd><p>Type of read <i>syscall</i>.</p></dd></dl><div class="spec module" id="module-Idx"><a href="#module-Idx" class="anchor"></a><code><span class="keyword">module</span> Idx = <a href="../index.html#module-Idx">Carton__.Idx</a></code></div><dl><dt class="spec module" id="module-Fp"><a href="#module-Fp" class="anchor"></a><code><span class="keyword">module</span> <a href="Fp/index.html">Fp</a> : <span class="keyword">functor</span> (<a href="Fp/argument-1-Uid/index.html">Uid</a> : <a href="../Sigs/index.html#module-type-UID">Carton__.Sigs.UID</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>('fd, 'uid) t</span></code></dt><dd><p>Type of state used to access to any objects into a <code>Carton</code> file.</p></dd></dl><aside><p>/</p></aside><dl><dt class="spec value" id="val-header_of_entry"><a href="#val-header_of_entry" class="anchor"></a><code><span class="keyword">val</span> header_of_entry : <span>map:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> <a href="W/index.html#type-slice">W.slice</a> <span>&#45;&gt;</span> int * int * int * <a href="W/index.html#type-slice">W.slice</a></code></dt></dl><aside><p>/</p></aside><dl><dt class="spec value" id="val-with_z"><a href="#val-with_z" class="anchor"></a><code><span class="keyword">val</span> with_z : Bigstringaf.t <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>with_z new t</code> replaces the used temporary buffer by <code>t</code> by <code>new</code>. Indeed, when the user wants to extract an object, the internal temporary buffer is used to store the inflated object. By this way, a parallel/concurrent computation of 2 extractions with the same <code>t</code> is unsafe.</p><p>So, this function allows the user to create a <i>new</i> <code>t</code> with a new dedicated temporary buffer (physically different from the old one) to be able to start a parallel/concurrent process.</p></dd></dl><dl><dt class="spec value" id="val-with_w"><a href="#val-with_w" class="anchor"></a><code><span class="keyword">val</span> with_w : <span><span class="type-var">'fd</span> <a href="W/index.html#type-t">W.t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>with_w w t</code> replaces the used table <a href="W/index.html#type-t"><code>W.t</code></a> by <code>w</code>. As <a href="index.html#val-with_z"><code>with_z</code></a>, the purpose of this function is to be able to <i>parallelize</i> multiple <a href="index.html#type-t"><code>t</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-with_allocate"><a href="#val-with_allocate" class="anchor"></a><code><span class="keyword">val</span> with_allocate : <span>allocate:<span>(int <span>&#45;&gt;</span> De.window)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>with_allocate allocate t</code> replaces the function to allocate the window needed to inflate objects by <code>allocate</code>. As <a href="index.html#val-with_z"><code>with_z</code></a>, the purpose of this function is to be able to <i>parallelize</i> multiple <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-fd"><a href="#val-fd" class="anchor"></a><code><span class="keyword">val</span> fd : <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'fd</span></code></dt><dd><p><code>fd t</code> returns the underlying used <code>fd</code> resource to map memory parts of it. On <code>Unix</code>, even if a mapped memory part can live if <code>fd</code> is the close, the resource should be open as long as the user extracts objects.</p></dd></dl><dl><dt class="spec type" id="type-raw"><a href="#type-raw" class="anchor"></a><code><span class="keyword">type</span> raw</code></dt><dd><p>Type of a <code>Carton</code> object as is into a <code>Carton</code> file.</p></dd></dl><dl><dt class="spec value" id="val-make_raw"><a href="#val-make_raw" class="anchor"></a><code><span class="keyword">val</span> make_raw : <span>weight:<a href="index.html#type-weight">weight</a></span> <span>&#45;&gt;</span> <a href="index.html#type-raw">raw</a></code></dt><dd><p><code>make_raw ~weight</code> allocates a raw.</p></dd></dl><dl><dt class="spec value" id="val-weight_of_raw"><a href="#val-weight_of_raw" class="anchor"></a><code><span class="keyword">val</span> weight_of_raw : <a href="index.html#type-raw">raw</a> <span>&#45;&gt;</span> <a href="index.html#type-weight">weight</a></code></dt></dl><dl><dt class="spec type" id="type-v"><a href="#type-v" class="anchor"></a><code><span class="keyword">type</span> v</code></dt><dd><p>Type of values.</p></dd></dl><dl><dt class="spec value" id="val-v"><a href="#val-v" class="anchor"></a><code><span class="keyword">val</span> v : <span>kind:<a href="../Sigs/index.html#type-kind">Carton__.Sigs.kind</a></span> <span>&#45;&gt;</span> <span>?&#8288;depth:int</span> <span>&#45;&gt;</span> Bigstringaf.t <span>&#45;&gt;</span> <a href="index.html#type-v">v</a></code></dt><dd><p><code>v ~kind ?depth raw</code> is a value <code>raw</code> typed by <code>kind</code>. <code>?depth</code> is an optional value to know at which depth the object exists into the PACK file it came from (default to <code>1</code>).</p></dd></dl><dl><dt class="spec value" id="val-kind"><a href="#val-kind" class="anchor"></a><code><span class="keyword">val</span> kind : <a href="index.html#type-v">v</a> <span>&#45;&gt;</span> <a href="../Sigs/index.html#type-kind">Carton__.Sigs.kind</a></code></dt><dd><p><code>kind v</code> is the type of the object <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-raw"><a href="#val-raw" class="anchor"></a><code><span class="keyword">val</span> raw : <a href="index.html#type-v">v</a> <span>&#45;&gt;</span> Bigstringaf.t</code></dt><dd><p><code>raw v</code> is the contents of the object <code>v</code>.</p><p><b>Note.</b> The <span class="xref-unresolved" title="unresolved reference to &quot;Bigstringaf.t&quot;"><code>Bigstringaf</code>.t</span> can be larger (and contain extra contents) than <code>len v</code> (see <a href="index.html#val-len"><code>len</code></a>). The user should <span class="xref-unresolved" title="unresolved reference to &quot;Bigstringaf.sub&quot;"><code>Bigstringaf</code>.sub</span> it with the real length of the object.</p></dd></dl><dl><dt class="spec value" id="val-len"><a href="#val-len" class="anchor"></a><code><span class="keyword">val</span> len : <a href="index.html#type-v">v</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>len v</code> is the length of the object <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-depth"><a href="#val-depth" class="anchor"></a><code><span class="keyword">val</span> depth : <a href="index.html#type-v">v</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>depth v</code> is the depth of the object into the PACK file it came from.</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <span class="type-var">'fd</span> <span>&#45;&gt;</span> <span>?&#8288;sector:int64</span> <span>&#45;&gt;</span> <span>z:Zl.bigstring</span> <span>&#45;&gt;</span> <span>allocate:<span>(int <span>&#45;&gt;</span> Zl.window)</span></span> <span>&#45;&gt;</span> <span>uid_ln:int</span> <span>&#45;&gt;</span> <span>uid_rw:<span>(string <span>&#45;&gt;</span> <span class="type-var">'uid</span>)</span></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'uid</span> <span>&#45;&gt;</span> int64)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>make fd ~z ~allocate ~uid_ln ~uid_rw where</code> returns a state associated to <code>fd</code> which is the user-defined representation of a <code>Carton</code> file. Some informations are needed:</p><ul><li><code>z</code> is an underlying buffer used to <i>inflate</i> an object.</li><li><code>allocate</code> is an <i>allocator</i> of underlying <i>window</i> used to <i>inflate</i> an object.</li><li><code>uid_ln</code> is the length of <i>raw</i> representation of user-defined <i>uid</i>.</li><li><code>uid_rw</code> is the <i>cast-function</i> from a string to user-defined <i>uid</i>.</li><li><code>where</code> is the function to associate an <i>uid</i> to an <i>offset</i> into the associated <code>Carton</code> file.</li></ul><p>Each argument depends on what the user wants. For example, if <code>t</code> is used by <a href="Verify/index.html#val-verify"><code>Verify.verify</code></a>, <code>allocate</code> <b>must</b> be thread-safe according to <code>IO</code>. <code>where</code> is not used by <a href="Verify/index.html#val-verify"><code>Verify.verify</code></a>. <code>uid_ln</code> and <code>uid_rw</code> depends on the <code>Carton</code> file associated by <code>fd</code>. Each functions available below describes precisely what they do on <code>t</code>.</p></dd></dl><section><header><h4 id="weight-of-object."><a href="#weight-of-object." class="anchor"></a>Weight of object.</h4><p>Before to extract an object, we must know resources needed to extract it. <code>weight_of_offset</code>/<code>weight_of_uid</code> do an simple analyse and return the larger length needed to store the requested object such as:</p><pre><code class="ml">weight_of_offset unix ~map t ~weight:null 0L &gt;&gt;= fun weight -&gt;
assert ((null :&gt; int) &lt;= (weight :&gt; int)) ;
Fmt.epr &quot;Object at %08Lx needs %d byte(s).\n%!&quot; 0L (weight :&gt; int) ;
let resource = make_raw ~weight in
...</code></pre><p>An object can need an other object (see <code>OBJ_OFS_DELTA</code> and <code>OBJ_REF_DELTA</code>). In this case, the resource needed must be larger/enough to store both objects. So the analyse is recursive over the <i>delta-chain</i>.</p><p><b>Note.</b> If the given PACK file represented by <code>t</code> is bad, <code>Cycle</code> is raised. It means that an object A refers to an object B which refers to our last object A.</p><p><b>Note.</b> This process is not <i>tail-rec</i> and discover at each step if it needs to continue the <i>delta-chain</i> or not.</p></header><dl><dt class="spec exception" id="exception-Cycle"><a href="#exception-Cycle" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Cycle</span></code></dt></dl><dl><dt class="spec value" id="val-weight_of_offset"><a href="#val-weight_of_offset" class="anchor"></a><code><span class="keyword">val</span> weight_of_offset : <span>map:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>weight:<a href="index.html#type-weight">weight</a></span> <span>&#45;&gt;</span> <span>?&#8288;visited:<span>int64 list</span></span> <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> <a href="index.html#type-weight">weight</a></code></dt><dd><p><code>weight_of_offset sched ~map t ~weight offset</code> returns the <code>weight</code> of the given object available at <code>offset</code> into <code>t</code>. This function assumes:</p><pre><code class="ml">weight_of_offset sched ~map t ~weight:a offset &gt;&gt;= fun b -&gt;
assert ((a :&gt; int) &lt;= (b :&gt; int))</code></pre><p><b>Note.</b> This function can try to partially inflate objects. So, this function can use internal buffers and it is not <i>thread-safe</i>.</p><p><b>Note.</b> This function can try to <i>look-up</i> an other object if it extracts an <code>OBJ_REF_DELTA</code> object. However, if we suppose that we process a PACKv2, an <code>OBJ_REF_DELTA</code> <i>usually</i> points to an external object (see <i>thin</i>-pack).</p></dd></dl><dl><dt class="spec value" id="val-weight_of_uid"><a href="#val-weight_of_uid" class="anchor"></a><code><span class="keyword">val</span> weight_of_uid : <span>map:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>weight:<a href="index.html#type-weight">weight</a></span> <span>&#45;&gt;</span> <span>?&#8288;visited:<span>int64 list</span></span> <span>&#45;&gt;</span> <span class="type-var">'uid</span> <span>&#45;&gt;</span> <a href="index.html#type-weight">weight</a></code></dt><dd><p><code>weight_of_offset sched ~map t ~weight uid</code> returns the <code>weight</code> of the given object identified by <code>uid</code> into <code>t</code>. This function assumes the same assumption as <a href="index.html#val-weight_of_offset"><code>weight_of_offset</code></a>.</p><p><b>Note.</b> As <a href="index.html#val-weight_of_offset"><code>weight_of_offset</code></a>, this function can inflate objects and use internal buffers and it is not <i>thread-safe</i>.</p><p><b>Note.</b> Despite <a href="index.html#val-weight_of_offset"><code>weight_of_offset</code></a>, this function <b>look-up</b> the object from the given reference.</p></dd></dl><dl><dt class="spec value" id="val-length_of_offset"><a href="#val-length_of_offset" class="anchor"></a><code><span class="keyword">val</span> length_of_offset : <span>map:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> int</code></dt></dl></section><section><header><h4 id="value-of-object."><a href="#value-of-object." class="anchor"></a>Value of object.</h4></header><dl><dt class="spec value" id="val-of_offset"><a href="#val-of_offset" class="anchor"></a><code><span class="keyword">val</span> of_offset : <span>map:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-raw">raw</a> <span>&#45;&gt;</span> <span>cursor:int64</span> <span>&#45;&gt;</span> <a href="index.html#type-v">v</a></code></dt><dd><p><code>of_offset sched ~map raw ~cursor</code> is the object at the offset <code>cursor</code> into <code>t</code>. The function is not <i>tail-recursive</i>. It discovers at each step if the object depends on another one (see <code>OBJ_REF_DELTA</code> or <code>OBJ_OFS_DELTA</code>).</p><p><b>Note.</b> This function does not allocate larges resources (or, at least, only the given <code>allocate</code> function to <a href="index.html#type-t"><code>t</code></a> is able to allocate a large resource). <code>raw</code> (which should be created with the associated <a href="index.html#type-weight"><code>weight</code></a> given by <a href="index.html#val-weight_of_offset"><code>weight_of_offset</code></a>) is enough to extract the object.</p></dd></dl><dl><dt class="spec value" id="val-of_uid"><a href="#val-of_uid" class="anchor"></a><code><span class="keyword">val</span> of_uid : <span>map:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-raw">raw</a> <span>&#45;&gt;</span> <span class="type-var">'uid</span> <span>&#45;&gt;</span> <a href="index.html#type-v">v</a></code></dt><dd><p>As <a href="index.html#val-of_offset"><code>of_offset</code></a>, <code>of_uid sched ~map raw uid</code> is the object identified by <code>uid</code> into <code>t</code>.</p></dd></dl></section><section><header><h4 id="path-of-object."><a href="#path-of-object." class="anchor"></a>Path of object.</h4><p>Due to the fact that <a href="index.html#val-of_offset"><code>of_offset</code></a>/<a href="index.html#val-of_uid"><code>of_uid</code></a> are not <i>tail-rec</i>, an other solution exists to extract an object from the PACK file. However, this solution requires a <i>meta-data</i> <a href="index.html#type-path"><code>path</code></a> to be able to extract an object.</p><p>A <a href="index.html#type-path"><code>path</code></a> is the <i>delta-chain</i> of the object. It assumes that a <i>delta-chain</i> can not be larger than <code>60</code> (see Git assumptions). From it, the way to construct an object is well-know and the step to discover if an object depends on an other one is deleted - and we ensure that the reconstruction is bound over our <a href="index.html#type-path"><code>path</code></a>.</p><p>This solution fits well when we want to <i>memoize</i> the extraction.</p></header><dl><dt class="spec type" id="type-path"><a href="#type-path" class="anchor"></a><code><span class="keyword">type</span> path</code></dt><dd><p>The type of paths.</p></dd></dl><dl><dt class="spec value" id="val-path_to_list"><a href="#val-path_to_list" class="anchor"></a><code><span class="keyword">val</span> path_to_list : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span>int64 list</span></code></dt><dd><p><code>path_to_list path</code> returns the <i>delta-chain</i> of the given <code>path</code>.</p></dd></dl><dl><dt class="spec value" id="val-kind_of_path"><a href="#val-kind_of_path" class="anchor"></a><code><span class="keyword">val</span> kind_of_path : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span>[ `A <span>| `B</span> <span>| `C</span> <span>| `D</span> ]</span></code></dt><dd><p><code>kind_of_path path</code> returns the kind of the object associated to the given <code>path</code>. An assumption exists about PACK format, a <i>delta-chain</i> refers to several objects which must have the same type/kind.</p></dd></dl><dl><dt class="spec value" id="val-path_of_offset"><a href="#val-path_of_offset" class="anchor"></a><code><span class="keyword">val</span> path_of_offset : <span>map:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>cursor:int64</span> <span>&#45;&gt;</span> <a href="index.html#type-path">path</a></code></dt><dd><p><code>path_of_offset sched ~map t ~cursor</code> is that <a href="index.html#type-path"><code>path</code></a> of the given object available at <code>cursor</code>.</p><p><b>Note.</b> This function can try to partially inflate objects. So, this function can use internal buffers and it is not <i>thread-safe</i>.</p><p><b>Note.</b> This function can try to <i>look-up</i> an other object if it extracts an <code>OBJ_REF_DELTA</code> object. However, if we suppose that we process a PACKv2, an <code>OBJ_REF_DELTA</code> <i>usually</i> points to an external object (see <i>thin</i>-pack).</p></dd></dl><dl><dt class="spec value" id="val-path_of_uid"><a href="#val-path_of_uid" class="anchor"></a><code><span class="keyword">val</span> path_of_uid : <span>map:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'uid</span> <span>&#45;&gt;</span> <a href="index.html#type-path">path</a></code></dt><dd><p><code>path_of_uid sched ~map t uid</code> is the <a href="index.html#type-path"><code>path</code></a> of the given object identified by <code>uid</code> into <code>t</code>.</p><p><b>Note.</b> As <a href="index.html#val-weight_of_offset"><code>weight_of_offset</code></a>, this function can inflate objects and use internal buffers and it is not <i>thread-safe</i>.</p><p><b>Note.</b> Despite <a href="index.html#val-weight_of_offset"><code>weight_of_offset</code></a>, this function <b>look-up</b> the object from the given reference.</p></dd></dl><dl><dt class="spec value" id="val-of_offset_with_path"><a href="#val-of_offset_with_path" class="anchor"></a><code><span class="keyword">val</span> of_offset_with_path : <span>map:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>path:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <a href="index.html#type-raw">raw</a> <span>&#45;&gt;</span> <span>cursor:int64</span> <span>&#45;&gt;</span> <a href="index.html#type-v">v</a></code></dt><dd><p><code>of_offset_with_path sched ~map t ~path raw ~cursor</code> is the object available at <code>cursor</code> into <code>t</code>. This function is <i>tail-recursive</i> and bound to the given <code>path</code>.</p></dd></dl></section><section><header><h4 id="uid-of-object."><a href="#uid-of-object." class="anchor"></a>Uid of object.</h4><p>Unique identifier of objects is a user-defined type which is not described by the format of the PACK file. By this fact, the way to <i>digest</i> an object is at the user's discretion. For example, Git <i>prepends</i> the value by an header such as:</p><pre><code class="ml">let digest v =
  let kind = match kind v with
    | `A -&gt; &quot;commit&quot;
    | `B -&gt; &quot;tree&quot;
    | `C -&gt; &quot;blob&quot;
    | `D -&gt; &quot;tag&quot; in
  let hdr = Fmt.str &quot;%s %d\000&quot; kind (len v) int
  let ctx = Digest.empty in
  feed_string ctx hdr ;
  feed_bigstring ctx (Bigstringaf.sub (raw v) 0 (len v)) ;
  finalize ctx</code></pre><p>Of course, the user can decide how to digest a value (see <a href="index.html#type-digest"><code>digest</code></a>). However, 2 objects with the same contents but different types should have different unique identifier.</p></header><dl><dt class="spec type" id="type-digest"><a href="#type-digest" class="anchor"></a><code><span class="keyword">type</span> <span>'uid digest</span></code><code> = <span>kind:<a href="../Sigs/index.html#type-kind">Carton__.Sigs.kind</a></span> <span>&#45;&gt;</span> <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> Bigstringaf.t <span>&#45;&gt;</span> <span class="type-var">'uid</span></code></dt></dl><dl><dt class="spec value" id="val-uid_of_offset"><a href="#val-uid_of_offset" class="anchor"></a><code><span class="keyword">val</span> uid_of_offset : <span>map:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span></span> <span>&#45;&gt;</span> <span>digest:<span><span class="type-var">'uid</span> <a href="index.html#type-digest">digest</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-raw">raw</a> <span>&#45;&gt;</span> <span>cursor:int64</span> <span>&#45;&gt;</span> <a href="../Sigs/index.html#type-kind">Carton__.Sigs.kind</a> * <span class="type-var">'uid</span></code></dt><dt class="spec value" id="val-uid_of_offset_with_source"><a href="#val-uid_of_offset_with_source" class="anchor"></a><code><span class="keyword">val</span> uid_of_offset_with_source : <span>map:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span></span> <span>&#45;&gt;</span> <span>digest:<span><span class="type-var">'uid</span> <a href="index.html#type-digest">digest</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>kind:<a href="../Sigs/index.html#type-kind">Carton__.Sigs.kind</a></span> <span>&#45;&gt;</span> <a href="index.html#type-raw">raw</a> <span>&#45;&gt;</span> <span>depth:int</span> <span>&#45;&gt;</span> <span>cursor:int64</span> <span>&#45;&gt;</span> <span class="type-var">'uid</span></code></dt></dl><dl><dt class="spec type" id="type-children"><a href="#type-children" class="anchor"></a><code><span class="keyword">type</span> <span>'uid children</span></code><code> = <span>cursor:int64</span> <span>&#45;&gt;</span> <span>uid:<span class="type-var">'uid</span></span> <span>&#45;&gt;</span> <span>int64 list</span></code></dt><dt class="spec type" id="type-where"><a href="#type-where" class="anchor"></a><code><span class="keyword">type</span> where</code><code> = <span>cursor:int64</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec type" id="type-oracle"><a href="#type-oracle" class="anchor"></a><code><span class="keyword">type</span> <span>'uid oracle</span></code><code> = </code><code>{</code><table class="record"><tr id="type-oracle.digest" class="anchored"><td class="def field"><a href="#type-oracle.digest" class="anchor"></a><code>digest : <span><span class="type-var">'uid</span> <a href="index.html#type-digest">digest</a></span>;</code></td></tr><tr id="type-oracle.children" class="anchored"><td class="def field"><a href="#type-oracle.children" class="anchor"></a><code>children : <span><span class="type-var">'uid</span> <a href="index.html#type-children">children</a></span>;</code></td></tr><tr id="type-oracle.where" class="anchored"><td class="def field"><a href="#type-oracle.where" class="anchor"></a><code>where : <a href="index.html#type-where">where</a>;</code></td></tr><tr id="type-oracle.weight" class="anchored"><td class="def field"><a href="#type-oracle.weight" class="anchor"></a><code>weight : <span>cursor:int64</span> <span>&#45;&gt;</span> <a href="index.html#type-weight">weight</a>;</code></td></tr></table><code>}</code></dt></dl></section><section><header><h4 id="verify."><a href="#verify." class="anchor"></a>Verify.</h4><p>When the user get a PACK file, he must generate an IDX file (see <a href="Idx/index.html"><code>Idx</code></a>) from it - to be able to look-up objects from their <code>uid</code>. <code>Verify</code> is a process which try to create an OCaml representation of the IDX file. This process requires some information (see <a href="index.html#type-oracle"><code>oracle</code></a>) which can be collected by a first analyse (see <a href="Fp/index.html"><code>Fp</code></a>). Then, the process wants to take the opportunity to <i>parallelize</i> extraction (depending on the <code>IO</code> implementation).</p></header><div class="spec module" id="module-Verify"><a href="#module-Verify" class="anchor"></a><code><span class="keyword">module</span> <a href="Verify/index.html">Verify</a> : <span class="keyword">functor</span> (<a href="Verify/argument-1-Uid/index.html">Uid</a> : <a href="../Sigs/index.html#module-type-UID">Carton__.Sigs.UID</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Verify/argument-2-Scheduler/index.html">Scheduler</a> : <a href="../Sigs/index.html#module-type-SCHEDULER">Carton__.Sigs.SCHEDULER</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Verify/argument-3-IO/index.html">IO</a> : <a href="../Sigs/index.html#module-type-IO">Carton__.Sigs.IO</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="Verify/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> <a href="Verify/argument-2-Scheduler/index.html#type-s">Scheduler.s</a></span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Ip"><a href="#module-Ip" class="anchor"></a><code><span class="keyword">module</span> <a href="Ip/index.html">Ip</a> : <span class="keyword">functor</span> (<a href="Ip/argument-1-Scheduler/index.html">Scheduler</a> : <a href="../Sigs/index.html#module-type-SCHEDULER">Carton__.Sigs.SCHEDULER</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Ip/argument-2-IO/index.html">IO</a> : <a href="../Sigs/index.html#module-type-IO">Carton__.Sigs.IO</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="Ip/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> <a href="Ip/argument-1-Scheduler/index.html#type-s">Scheduler.s</a></span>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Ip/argument-3-Uid/index.html">Uid</a> : <a href="../Sigs/index.html#module-type-UID">Carton__.Sigs.UID</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>